
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Server E2E tests using JavaScript</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="bower_components/reveal-js/css/reveal.css">
    <link rel="stylesheet" href="bower_components/reveal-js/css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="bower_components/reveal-js/lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
        if( window.location.search.match( /print-pdf/gi ) ) {
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = 'bower_components/reveal-js/css/print/pdf.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        }
    </script>

    <!--[if lt IE 9]>
    <script src="bower_components/reveal-js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section>
    <h2>Server End-to-End testing using</h2>
    <h1>JavaScript</h1>
    <h3>By Mantas Indrasius</h3>
</section>

<section>
    <h2>Agenda</h2>
    <ul>
        <li>Why bother?</li>
        <li>REST + HTML, Sometimes XML</li>
        <li>Type safety shit</li>
        <li>Examples of current E2E</li>
        <li>Requirements</li>
        <li>Mocha & Jasmine</li>
        <li>Pros & cons for each</li>
        <li>node.js + jsdom + mocha</li>
        <li>phantom?</li>
        <li>Nashorn + Avatar.js</li>
        <li>Karma + jasmine, how karma is running</li>
        <li>IDE integration</li>
        <li>Tests become shared</li>
        <li>The winner is</li>
    </ul>

    <aside class="notes">
        Side notes (hit 's' on your keyboard).
    </aside>
</section>

<!-- Example of nested vertical slides -->
<section>
    <h1>Acceptance tests is not our topic today</h1>
</section>
<section>
    <h1>So what are we going to talk about?</h1>
    <p class="current-visible grow">In server development E2E tests is a nickname for server component tests.</p>
</section>
<section>
    <section>
        <h1>So why JavaScript?</h1>
    </section>
    <section>
        <h2>Closer environment</h2>
        <ul>
            <li>E2E should run in as close environment as possible</li>
            <li>So we have better edge-to-edge converage</li>
            <li>We serve for JavaScript that runs in a browser</li>
            <li>We find the same DOM implementation</li>
        </ul>
    </section>
    <section>
        <h2>Why be a type-safe?</h2>
        <ul>
            <li>It's HTML, JSON, sometimes XML</li>
            <li>No type-safety, no schemas</li>
            <li>Our task is to dispatch a request and assert the response</li>
            <li>It's all about contract</li>
        </ul>
    </section>
    <section>
        <h2>Fluent syntax</h2>
        <ul>
            <li>Object literal maps ~1:1 to the JSON message</li>
            <li>Async in tests is more fluent</li>
            <li>Matchers are still around</li>
        </ul>
    </section>
    <section>
        <h2>Faster feedback</h2>
        <ul>
            <li>No compilation step is required for a test run</li>
            <li>Test execution speed plays little part in overall performance</li>
        </ul>
    </section>
    <section>
        <h2>Technology agnostic</h2>
        <ul>
            <li>The tests become shared with the client end</li>
            <li>No need to rewrite the tests if move from the current technology</li>
            <li>You can run the tests from Grunt, Gulp and other tools</li>
        </ul>
    </section>
    <section>
        <h2>Example</h2>
        <pre>
            <code>
    describe("a product service", function() {
        var client = new HttpClient('http://localhost:9777/');

        it("processes the order successfully", () =>
            whenOrderItemExists({ orderId: 12345 })
                .then(() => http.post('order/12345/process'))
                .then(gotResult => expect(gotResult).to.beSuccessful)
        );
    });
            </code>
        </pre>
    </section>
</section>
<section>
    <h1>Let's work out a solution for that</h1>
</section>
<section>
    <h2>Requirements</h2>
    <ul>
        <li>Out-of-the-box for the server developer</li>
        <li>No dependency to JS build tools</li>
        <li>At least a minimal IDE support</li>
        <li>Integrated into the server build</li>
        <li>CI support</li>
        <li>HTML scripts must not be executed on load</li>
        <li>Should support matching both HTML and JSON (duh)</li>
        <li>It should be possible to add JS dependencies</li>
    </ul>
</section>

<section>
    <h2>Things to consider</h2>
    <ul>
        <li>Two execution contexts: node.js and browser window</li>
        <li>Imports & dependencies are managed differently</li>
        <li>Tests should be written for either one or another, sharing is not nice</li>
        <li>Promises vs. callbacks</li>
    </ul>
</section>

<section>
    <section>
        <h2>How to run it from the Scala/Java project?</h2>
        <ul>
            <li>We can write a custom test runner (JUnit, sbt test interface etc.)</li>
            <li>The runner starts the environment</li>
            <li>Which configures the execution environment (dependencies, config files, reporters, test framework)</li>
            <li>Tests are executed while the runner consumes the report output</li>
            <li>Report events are translated into the running framework</li>
        </ul>
    </section>
    <section>
        <h2>JUnit custom runner example</h2>
        <pre>
            <code class="scala" style="height: 800">
    override def run(notifier: RunNotifier): Unit = {
        notifier.fireTestStarted(aDescriptionFor("Success test"))
        notifier.fireTestStarted(aDescriptionFor("Failing test"))

        notifier.fireTestFinished(aDescriptionFor("Success test"))
        notifier.fireTestFailure(aFailureFor("It went wrong", assertion = "true expected to be false"))
    }
            </code>
        </pre>
    </section>
</section>

<section>
    <section>
        <h1>What has been dismissed</h1>
        <ul>
            <li>Bare PhantomJS</li>
            <li>Nashorn + Avatar.js</li>
        </ul>
    </section>

    <section>
        <section>
            <h1>PhantomJS</h1>
        </section>
        <section>
            <h2>Page automation</h2>
        <pre>
            <code>
                var page = require('webpage').create();
                var url = 'http://localhost:9999/greeting.html';

                page.open(url, function(status) {
                var elements = page.evaluate(function() {
                return $('span').length;
                });

                phantom.exit();
                });
            </code>
        </pre>
        </section>
        <section>
            <h2>How would it work</h2>
            <ul>
                <li>Start a context server</li>
                <li>Create a page object and load the context page</li>
                <li>Run tests that use XHR calls</li>
            </ul>
        </section>
        <section>
            <h2>Pros</h2>
            <ul>
                <li>Direct control</li>
                <li>Close to the real thing</li>
            </ul>
        </section>
        <section>
            <h2>Cons</h2>
            <ul>
                <li>Reinventing a wheel</li>
                <li>Hard to manage</li>
                <li>1.9.8 using an old webkit (from Chrome 13)</li>
                <li>2.0.0 has a newer one, but won't have the official release</li>
            </ul>
        </section>
        <section>
            <h1>Dismissed</h1>
        </section>
    </section>

    <section>
        <section>
            <h1>Nashorn</h1>
        </section>
        <section>
            <h2>Hello John</h2>
        <pre>
            <code class="java">
    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
    ScriptEngine nashorn = scriptEngineManager.getEngineByName("nashorn");

    String name = "John";
    nashorn.eval("print('Hello " + name + "')");
            </code>
        </pre>
        </section>
        <section>
            <h2>Avatar.js (aka node.jar)</h2>
            <p>The goal is to support the Node.js programming model and libs</p>
            <p class="fragment current-visible grow">Still under development</p>
        </section>
        <section>
            <h2>This works</h2>
        <pre>
            <code>
    var http = require('http');

    function handleRequest(req, res) {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end('Hello, World\n');
    }

    http.createServer(handleRequest).listen(1337, '127.0.0.1');
            </code>
        </pre>
        </section>
        <section>
            <h2>Pros</h2>
            <ul>
                <li>JVM option</li>
                <li>Fast boot</li>
                <li>Multithreaded</li>
            </ul>
        </section>
        <section>
            <h2>Cons</h2>
            <ul>
                <li>It's only syntax</li>
                <li>Avatar.js (aka node.jar) requires JNI libs</li>
                <li>No out-of-the-box solution</li>
                <li>Barebone solution is hard to get working (test runners, deps)</li>
            </ul>
        </section>
        <section>
            <h1>Dismissed</h1>
        </section>
    </section>
</section>

<section>
    <section>
        <h1>The test frameworks</h1>
        <ul>
            <li>Jasmine</li>
            <li>Mocha + Chai</li>
        </ul>
    </section>
    <section>
        <ul>
            <li>Jasmine is more feature rich</li>
            <li>But Mocha treats the promises well</li>
            <li>And is easier to run in different environments</li>
        </ul>
    </section>
    <section>
        <h2>Jasmine example</h2>
        <pre>
            <code>
    it("display the greeting to the user", done => {
        whenOrderExists({ orderId: 12345 })
            .then(() => http.post('orders/12345/process', {}))
            .then(gotResult => { expect(gotResult).toBe('OK'); })
            .catch(err => fail(err))
            .then(done);
    });
            </code>
        </pre>
    </section>
    <section>
        <h2>Mocha + Chai example</h2>
        <pre>
            <code>
    it("display the greeting to the user", () =>
        whenOrderExists({ orderId: 12345 })
            .then(() => http.post('orders/12345/process', {}))
            .then(gotResult => expect(gotResult).to.be.equal('OK'))
    );
            </code>
        </pre>
    </section>
</section>

<section>
    <h1>Let's focus on these 2</h1>
    <ul>
        <li>Node.js</li>
        <li>Karma</li>
    </ul>
</section>


<section>
    <section>
        <h1>Node.js</h1>
     </section>
    <section>
        <h2>Pros</h2>
        <ul>
            <li>Fast boot</li>
            <li>Rich infrastructure capabilities</li>
            <li>Possibility to have a node-based test environment (i.e. fake servers)</li>
            <li>Built-in dependency management</li>
        </ul>
     </section>
    <section>
        <h2>Cons</h2>
        <ul>
            <li>It's not a browser env</li>
            <li>Harder to inject the configuration</li>
            <li>jsdom has issues related to contextify lib (fortunately there is a fork jsdom-no-contextify)</li>
        </ul>
    </section>
    <section>
        <h1>See how it works</h1>
    </section>
</section>

<section>
    <section>
        <h1>Karma</h1>
    </section>

    <section>
        <h3>The configuration</h3>
        <pre>
            <code>
    module.exports = function(config) {
      config.set({
        basePath: '',
        frameworks: ['jasmine'],
        files: [
          'file1.js', 'file2.js'
        ],
        reporters: ['teamcity'],
        colors: false,
        logLevel: config.LOG_INFO,
        autoWatch: false,
        browsers: ['PhantomJS_without_security'],
        browserNoActivityTimeout: 1000,
        singleRun: false,
        customLaunchers: {
          PhantomJS_without_security: {
            base: 'PhantomJS',
            flags: ['--web-security=no']
          }
        }
      });
    };
            </code>
        </pre>
    </section>

    <section>
        <h2>Pros</h2>
        <ul>
            <li>Mature & powerful</li>
            <li>Using the actual browser stack</li>
            <li>Possibility to test on multiple browser vendors and versions</li>
            <li>Using external context</li>
        </ul>
    </section>

    <section>
        <h2>Cons</h2>
        <ul>
            <li>Takes a second to start</li>
        </ul>
    </section>

    <section>
        <h1>See how it works</h1>
    </section>
</section>

<section>
    <section>
        <h1>To conclude</h1>
    </section>
    <section>
        <p>Both Node.js and Karma are feasible approaches.</p>
        <p class="fragment roll-in">Karma is slower to start, but using the actual XHR and DOM implementation</p>
        <p class="fragment roll-in">Node.js is fast and has great possibilities to host the whole server E2E infrastructure</p>
        <p class="fragment roll-in">We could actually combine them</p>
    </section>
</section>

<section>
    <h1>Thank You</h1>
</section>

</div>

</div>

<script src="bower_components/reveal-js/lib/js/head.min.js"></script>
<script src="bower_components/reveal-js/js/reveal.min.js"></script>
<script src="socket.io/socket.io.js"></script>

<script>
    var revealRoot = "bower_components/reveal-js/";

    var socket = io.connect("http://192.168.0.103:3000");

    socket.on("message", function(data){
        console.log(data);
    });

    socket.on("slidechanged", function(data){
        Reveal.slide(data.indexh, data.indexv, data.indexf);
    });

    // Full list of configuration options available here:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'linear',
        backgroundTransition: 'default',
        width: 1280,
        height: 1600,

        theme: 'beige',

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
            { src: revealRoot + 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: revealRoot + 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: revealRoot + 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: revealRoot + 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: revealRoot + 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
            { src: revealRoot + 'plugin/notes/notes.js', async: false, condition: function() { return !!document.body.classList; } }
        ]
    });

    var notifyServer = function(event){
        data = {
            indexv : Reveal.getIndices().v,
            indexh : Reveal.getIndices().h,
            indexf : Reveal.getIndices().f || 0
        };

        socket.emit("slidechanged" , data);
    };


    if (location.search === '?master') {
        Reveal.addEventListener("slidechanged", notifyServer);
        Reveal.addEventListener("fragmentshown", notifyServer);
        Reveal.addEventListener("fragmenthidden", notifyServer);

        Reveal.addEventListener( 'ready', function(event) {
            RevealNotes.open();
        });
    }
</script>

</body>
</html>
